Question:
 5. Scheme:  Assuming you have a hash table named hash, which contains
    pointers to binary functions, Write code to evaluate an expression
    tree.  The tree is represented as three element lists, where car is
    the function, cadr is the left operand, and caddr is the right
    operand.  Leaf nodes are symbols whose values are in the table
    symtab, also a hash.  You need not do error checking:  all variables
    and operators are valid, all leaf nodes are symbols, and all
    interior nodes have exactly three elements.  [3pt]

    (define (evaltree tree)

Overlapped: set(['function', 'cadr', 'right', 'checking', 'car', 'variables', 'contains', 'tree', 'functions', 'element', 'write', 'elements', 'left', 'table', 'nodes', 'scheme', 'define']) 
Overlap: 17 
Accuracy: 0.226666666667 

Question:
 3. Scheme:  Without using any higher-order functions, define the
    function map whose first argument is a function, which is applied to
    each element of its second argument, a list.  The result returned as
    a new list.  [2pt]

    > (map (lambda (x) (* x x)) '(1 2 3 4 5))
    (1 4 9 16 25)

Overlapped: set(['function', 'map', 'functions', 'lambda', 'list', 'argument', 'first', 'element', 'second', 'without', 'x', 'using', 'new', 'scheme', 'define']) 
Overlap: 15 
Accuracy: 0.245901639344 

Question:
 8. Scheme:  Without using any higher order functions, code reverse,
    which reverses a list.  Hint:  Think about two stacks.  Use tail
    recursive form and a helper function that uses accumulator style.
    [2pt]

Overlapped: set(['function', 'style', 'reverse', 'helper', 'use', 'list', 'functions', 'two', 'tail', 'without', 'using', 'scheme', 'order', 'higher']) 
Overlap: 14 
Accuracy: 0.411764705882 

Question:
 7. Scheme:  Define a function split that takes a single list argument
    and returns a list of two elements, with the car of the result
    containing the odd numberd elements (counting from 1) cdr the even
    numbered elements.  The elements remain in the same relative order.
    [3pt]

    > (split '(1 2 3 4 5 6 7 8 9))
    ((1 3 5 7 9) (2 4 6 8))

Overlapped: set(['even', 'function', 'elements', 'car', 'list', 'argument', 'two', 'returns', 'cdr', 'scheme', 'odd', 'order', 'define']) 
Overlap: 13 
Accuracy: 0.188405797101 

Question:
 5. Fold right (foldr) uses up how much stack space on a list of length
    $n$?
    (A) $ O ( 1 ) $
    (B) $ O ( 2 sup n ) $
    (C) $ O ( log sub 2 n ) $
    (D) $ O ( n ) $

Overlapped: set(['c', 'right', 'sub', 'space', 'list', 'n', 'fold', 'length', 'much', 'sup', 'b', 'stack', 'log']) 
Overlap: 13 
Accuracy: 0.254901960784 

Question:
 2. Scheme:  Define the function foldl, which has three arguments in
    this order:  a function, a unit, and a list.  A single result is
    returned such that the function is applied to the unit and the car
    of the list, sending that down as the next unit, and the cdr of the
    list is sent in on each recursive call.  It is tail recursive.
    [2pt]

    Using foldl, define the function length, which returns the length of
    a list.  [1pt]

Overlapped: set(['function', 'length', 'car', 'list', 'tail', 'returns', 'arguments', 'cdr', 'using', 'scheme', 'order', 'define']) 
Overlap: 12 
Accuracy: 0.214285714286 

Question:
 4. C++:  Define a function print whose argument is a vector<string>,
    and which uses an iterator to print out all of the elements, one per
    line.  [2pt]

    Instead, for an extra point, make it a template function whose type
    can be anything for which operator<< is properly defined.  [1pt]

Overlapped: set(['function', 'elements', 'string', 'point', 'defined', 'argument', 'one', 'vector', 'line', 'type', 'define']) 
Overlap: 11 
Accuracy: 0.244444444444 

Question:
 6. Perl:  Define a function fold, which uses a loop to join all
    elements of an array into a single value.  Its first argument is a
    reference to a binary function, it second argument is a unit value,
    and its third argument is a reference to an array.  [2pt]

    print fold sub{$_[0]+$_[1]}, 0, [1, 2, 3, 4, 5, 6];
    21

Overlapped: set(['function', 'elements', 'sub', 'argument', 'value', 'perl', 'fold', 'second', 'array', 'first', 'define']) 
Overlap: 11 
Accuracy: 0.161764705882 

Question:
 1. Scheme:  The following function by filius Bonacci takes $ O ( 2 sup
    n ) $ time and $ O ( n ) $ stack.  Recode it using a helper function
    so that it takes $ O ( n ) $ time and $ O ( 1 ) $ stack.  [2pt]
    (define (f n) (if (< n 2) n (+ (f (- n 1)) (f (- n 2)))))

Overlapped: set(['function', 'helper', 'f', 'n', 'sup', 'following', 'using', 'scheme', 'stack', 'define']) 
Overlap: 10 
Accuracy: 0.128205128205 

Question:
 6. In the following statement, continue goes to what part ?
          for (i = 0; i < n; ++i) {
             f (); continue; g ();
          } h ();
    (A) ++i
    (B) h ();
    (C) i < n
    (D) i = 0

Overlapped: set(['c', 'b', 'g', 'f', 'h', 'n', 'continue', 'statement', 'following']) 
Overlap: 9 
Accuracy: 0.173076923077 

Question:
 8. Both Perl and Scheme have type systems which are:
    (A) strong and dynamic.
    (B) strong and static.
    (C) weak and dynamic.
    (D) weak and static.

Overlapped: set(['c', 'strong', 'weak', 'dynamic', 'perl', 'b', 'static', 'scheme', 'type']) 
Overlap: 9 
Accuracy: 0.321428571429 

Question:
 3. What might cause a dangling pointer in C++?
    (A) catch
    (B) delete
    (C) new
    (D) throw

Overlapped: set(['c', 'b', 'cause', 'new', 'might', 'throw', 'pointer']) 
Overlap: 7 
Accuracy: 0.333333333333 

Question:
 7. What declares a variable m of type map whose keys are strings and
    whose values are ints?
    (A) m: (string, int) map;
    (B) map <string, int> m;
    (C) map [int, string] m;
    (D) map m <string, int>;

Overlapped: set(['map', 'c', 'b', 'string', 'int', 'variable', 'type']) 
Overlap: 7 
Accuracy: 0.137254901961 

Question:
 9. For which function will C++ say:  Warning:  Returning a reference to
    a local variable or temporary.
    (A) int &f (int &i) {int j; return j; }
    (B) int f (int &i) {int j; return j; }
    (C) int f (int i) {int j; return j; }
    (D) int f (int i) {int &j; return j; }

Overlapped: set(['function', 'c', 'b', 'return', 'f', 'int', 'variable']) 
Overlap: 7 
Accuracy: 0.0886075949367 

Question:
 1. What expression will print (3)?
    (A) (caar '(1 2 3))
    (B) (cadr '(1 2 3))
    (C) (cdar '(1 2 3))
    (D) (cddr '(1 2 3))

Overlapped: set(['c', 'b', 'cdar', 'cadr', 'caar', 'cddr']) 
Overlap: 6 
Accuracy: 0.11320754717 

Question:
 4. In Ocaml, what is the type of the function (+)?
    (A) int * int * int
    (B) int * int -> int
    (C) int -> int * int
    (D) int -> int -> int

Overlapped: set(['function', 'c', 'b', 'int', 'ocaml', 'type']) 
Overlap: 6 
Accuracy: 0.139534883721 

Question:
 2. What variable in a command in a Makefile has as its value the target
    of the recipe?
    (A) $*
    (B) $<
    (C) $?
    (D) $@

Overlapped: set(['variable', 'c', 'b', 'value']) 
Overlap: 4 
Accuracy: 0.153846153846 

Question:
10. In C++, which of these operators is ``lazy''?
    (A) &&
    (B) ++
    (C) <<
    (D) ==

Overlapped: set(['c', 'b']) 
Overlap: 2 
Accuracy: 0.0833333333333 

Question:
Overlapped: set([]) 
Overlap: 0 
Accuracy: 0 

